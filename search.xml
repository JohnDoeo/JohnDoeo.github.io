<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot1项目升级到springboot2（踩坑）]]></title>
    <url>%2F2019%2F07%2F09%2Fspringboot1%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7%E5%88%B0springboot2%EF%BC%88%E8%B8%A9%E5%9D%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一：首先需要把pom.xml中的parent节点中version改为2.X版本，我这里改为2.1.5.RELEASE接下来修改application.yml文件，先把yml文件中的spring上传文件大小限制的配置进行修改： 1234567#文件上传配置 1.5.9 spring: http: multipart: enabled: true max-file-size: 100Mb max-request-size:100Mb 1234567##文件上传配置 2.1.5 spring: servlet: multipart: enabled: true max-file-size: 100Mb max-request-size: 100Mb 修改redis相关配置： 1234567 #redis部分配置 1.5.9redis: pool: max-idle: 60 min-idle: 30 max-wait: -1 max-active: 200 12345678 ##redis部分配置 2.1.5redis: jedis: pool: max-idle: 60 min-idle: 30 max-wait: -1 max-active: 200 yml配置文件修改完毕了，启动以下项目报错：org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;这两个类找不到：查了资料发现在springboot2以后使用 org.springframework.boot.web.server.WebServerFactoryCustomizer;替换了org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;使用org.springframework.boot.web.server.ConfigurableWebServerFactory;替换了org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer，所以这个地方把这两个类换掉基本就可以了 再次启动有报错：找不到groovy.util.logging.Slf4j;这里直接把这个引入删除就可以了，不知道这个以前是干什么的，不管了，先进行下一步 再次启动有报错： 12345Error:(31, 37) java: 对于RedisCacheManager(org.springframework.data.redis.core.RedisTemplate&lt;capture#1, 共 ?,capture#2, 共 ?&gt;), 找不到合适的构造器 构造器 org.springframework.data.redis.cache.RedisCacheManager.RedisCacheManager(org.springframework.data.redis.cache.RedisCacheWriter,org.springframework.data.redis.cache.RedisCacheConfiguration,java.lang.String...)不适用 (参数不匹配; org.springframework.data.redis.core.RedisTemplate&lt;capture#1, 共 ?,capture#2, 共 ?&gt;无法转换为org.springframework.data.redis.cache.RedisCacheWriter) 构造器 org.springframework.data.redis.cache.RedisCacheManager.RedisCacheManager(org.springframework.data.redis.cache.RedisCacheWriter,org.springframework.data.redis.cache.RedisCacheConfiguration,boolean,java.lang.String...)不适用 (参数不匹配; org.springframework.data.redis.core.RedisTemplate&lt;capture#1, 共 ?,capture#2, 共 ?&gt;无法转换为org.springframework.data.redis.cache.RedisCacheWriter) 我的redis相关配置类如下： 1234567891011121314151617181920212223242526272829303132333435363738394041@Configuration@EnableCachingpublic class RedisConfig &#123; /** * 缓存管理器 */ @Bean public CacheManager cacheManager(RedisTemplate&lt;?,?&gt; redisTemplate) &#123; CacheManager cacheManager = new RedisCacheManager(redisTemplate); return cacheManager; &#125; /** * RedisTemplate */ @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(factory); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); // hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // value序列化方式采用jackson template.setValueSerializer(jackson2JsonRedisSerializer); // hash的value序列化方式采用jackson template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; &#125;&#125; 主要原因在这里： 12345@Beanpublic CacheManager cacheManager(RedisTemplate&lt;?,?&gt; redisTemplate) &#123; CacheManager cacheManager = new RedisCacheManager(redisTemplate); return cacheManager;&#125; 需要修改为这样的： 12345@Bean public CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisCacheManager build = RedisCacheManager.builder(factory).build(); return build; &#125; ok，再重新启动：又报错了： 123456789101112131415161718192021org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;scheduledTask&apos;: Unsatisfied dependency expressed through field &apos;visitorService&apos;; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;visitorServiceImpl&apos;: Unsatisfied dependency expressed through field &apos;visitorMapper&apos;; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;visitorMapper&apos; defined in file [D:\javaProject\MyBlog-1-master\target\classes\com\zhy\mapper\VisitorMapper.class]: Unsatisfied dependency expressed through bean property &apos;sqlSessionFactory&apos;; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;sqlSessionFactory&apos; defined in class path resource [org/mybatis/spring/boot/autoconfigure/MybatisAutoConfiguration.class]: Unsatisfied dependency expressed through method &apos;sqlSessionFactory&apos; parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;druidDataSource&apos; defined in class path resource [com/zhy/config/DruidDataSourceConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [javax.sql.DataSource]: Factory method &apos;dataSource&apos; threw exception; nested exception is java.lang.NumberFormatException: null at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:596) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:90) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:374) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1411) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:592) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:843) ~[spring-beans-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:877) ~[spring-context-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) ~[spring-context-5.1.7.RELEASE.jar:5.1.7.RELEASE] at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) ~[spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) [spring-boot-2.1.5.RELEASE.jar:2.1.5.RELEASE] at com.zhy.MyBlogApplication.main(MyBlogApplication.java:19) [classes/:na] 从抛出的异常可以发现是自己的配置类DruidDataSourceConfig无法进行实例化，发现是我把yml中的数据源的配置字符串和阿里数据源的配置类中的字符串不对应]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用正则表达式字符串整理]]></title>
    <url>%2F2019%2F07%2F09%2F%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[原文链接 一：校验数字表达式：123456789101112131415161718191 数字：^[0-9]*$ 2 n位的数字：^\d&#123;n&#125;$ 3 至少n位的数字：^\d&#123;n,&#125;$ 4 m-n位的数字：^\d&#123;m,n&#125;$ 5 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ 7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$ 8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 9 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$10 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$12 非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$13 非负整数：^\d+$ 或 ^[1-9]\d*|0$14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 二：校验字符表达式：12345678910111 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$3 长度为3-20的所有字符：^.&#123;3,20&#125;$4 由26个英文字母组成的字符串：^[A-Za-z]+$5 由26个大写英文字母组成的字符串：^[A-Z]+$6 由26个小写英文字母组成的字符串：^[a-z]+$7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$11 可以输入含有^%&amp;&apos;,;=?$\&quot;等字符：[^%&amp;&apos;,;=?$\x22]+12 禁止输入含有~的字符：[^~\x22]+ 三：特殊需求表达式：123456789101112131415161718192021222324252627282930313233341 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 2 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? 3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$ 5 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$ 6 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125; 7 身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$ 8 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$ 9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 12 日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$15 钱的输入格式：16 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$20 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$24 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$26 中文字符的正则表达式：[\u4e00-\u9fa5]27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)29 HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)30 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)31 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)32 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)33 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)34 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d) 以上是原文内容，后续遇到其他的还会持续更新的]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot+elasticsearch+mybatis+mysql（二：mysql数据全量/增量同步到es）]]></title>
    <url>%2F2019%2F07%2F09%2Fspringboot-elasticsearch-mybatis-mysql%EF%BC%88%E4%BA%8C%EF%BC%9Amysql%E6%95%B0%E6%8D%AE%E5%85%A8%E9%87%8F-%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E5%88%B0es%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一篇已经实现了springboot和es的简单整合，基本可以通过springboot来查询es中的数据了，接下来就要实现把mysql中的数据同步到es中，方便进行数据查询同步数据又几种方法，我这里使用logstash进行数据同步1. 首先到官网下载logstash下载地址在这里可以找到我这里使用的同一版本为6.4.3的2.进入${LOGSTASH_HOME}\config新建jdbc.conf文件，内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152input &#123; stdin &#123;&#125; jdbc &#123; #mysql的jdbc连接工具jar包 jdbc_driver_library =&gt; &quot;C:\Users\JohnDoeo\.m2\repository\mysql\mysql-connector-java\6.0.6\mysql-connector-java-6.0.6.jar&quot; #jdbc驱动类全类名 jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot; #jdbc连接url jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC&quot; #数据库用户名 jdbc_user =&gt; &quot;yourusername&quot; #数据库密码 jdbc_password =&gt; &quot;yourpassword&quot; #数据同步时间及那个（都是*则每一分钟同步一次） schedule =&gt; &quot;* * * * *&quot; #jdbc分页查询开启 jdbc_paging_enabled =&gt; &quot;true&quot; #查询每页显示数据条数 jdbc_page_size =&gt; &quot;50000&quot; #sql文件路径（就是需要同步的数据） statement_filepath =&gt; &quot;D:/ELK/logstash-6.4.3/config/jdbc.sql&quot; #上次更新位置标记文件路径 last_run_metadata_path =&gt; &quot;D:/ELK/logstash-6.4.3/config/test-config/jobLastInfo.txt&quot; #每次启动是否清除上一项配置文件中数据 clean_run =&gt; &quot;false&quot; #开启所有字段名转成小写 lowercase_column_names =&gt; &quot;true&quot; #解决中文乱码问题 codec =&gt; plain &#123; charset =&gt; &quot;UTF-8&quot;&#125; type =&gt; &quot;job&quot; &#125;&#125;filter &#123; json &#123; source =&gt; &quot;message&quot; remove_field =&gt; [&quot;message&quot;] &#125;&#125;output &#123; elasticsearch &#123; index =&gt; &quot;job&quot; document_type =&gt; &quot;%&#123;type&#125;&quot; #es服务器 hosts =&gt; &quot;localhost:9200&quot; document_id =&gt; &quot;%&#123;id&#125;&quot; &#125; stdout &#123; codec =&gt; json_lines &#125;&#125; 接下来在相同目录下创建jdbc.sql文件，内容如下： 1select * from job 这里如果希望进行增量同步的话就要在jdbc.conf中添加相关配置如下 1234567891011121314151617181920212223242526272829303132333435jdbc &#123; #mysql的jdbc连接工具jar包 jdbc_driver_library =&gt; &quot;C:\Users\JohnDoeo\.m2\repository\mysql\mysql-connector-java\6.0.6\mysql-connector-java-6.0.6.jar&quot; #jdbc驱动类全类名 jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot; #jdbc连接url jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC&quot; #数据库用户名 jdbc_user =&gt; &quot;yourusername&quot; #数据库密码 jdbc_password =&gt; &quot;yourpassword&quot; #数据同步时间及那个（都是*则每一分钟同步一次） schedule =&gt; &quot;* * * * *&quot; #jdbc分页查询开启 jdbc_paging_enabled =&gt; &quot;true&quot; #查询每页显示数据条数 jdbc_page_size =&gt; &quot;50000&quot; #sql文件路径（就是需要同步的数据） statement_filepath =&gt; &quot;D:/ELK/logstash-6.4.3/config/jdbc.sql&quot; #上次更新位置标记文件路径 last_run_metadata_path =&gt; &quot;D:/ELK/logstash-6.4.3/config/test-config/jobLastInfo.txt&quot; #每次启动是否清除上一项配置文件中数据clean_run =&gt; &quot;false&quot; #开启所有字段名转成小写lowercase_column_names =&gt; &quot;true&quot;#解决中文乱码问题codec =&gt; plain &#123; charset =&gt; &quot;UTF-8&quot;&#125;#是否记录上次运行的记录record_last_run =&gt; &quot;true&quot;#是否使用其他字段判断进行数据库同步use_column_value =&gt; &quot;true&quot;#数据库中的增量指标字段名tracking_column =&gt; &quot;last_modify_time&quot; type =&gt; &quot;job&quot; &#125; 并且还要修改jdbc.sql文件： 1select * from job as j where j.last_modify_time &gt; :sql_last_value 注意：这里的last_modify_time就是jdbc.conf中的tracking_column节点对应的mysql数据库字段名，并且数据库中的增量指标字段类型目前只支持两种numeric,timestamp 由于我这里只是做一个测试，所有这里就只是查询出一个表job中所有的字段进行同步到es中 3.接下来就可以启动进行测试了ok，接下来就可以先启动es，待es 启动完成，启动logstash，启动命令： 1$&#123;LOGSTASH_HOME&#125;\bin\logstash.bat -f $&#123;LOGSTASH_HOME&#125;\config\jdbc.conf 稍等就可以看到logstash启动成功的消息，然后dos窗口就会自动输出logstash进行同步数据的提示信息：如果想直接查看es中的数据可以有两种方法：（1）使用elasticsearch-head（这种方法需要先安装node.js），可以在这里下载源码，放在es根目录下，然后使用命令行进入elasticsearch-head-master目录下执行命令： 1npm install 安装grunt工具 1npm install -g grunt-cli 修改es-head配置文件${ES_HEAD}\Gruntfile.js在grunt.initConfig节点下：connect: { server: { options: { port: 9100, base: &#39;.&#39;, keepalive: true } } } 在options中添加节点hostname: ‘0.0.0.0’,至此es-head插件的配置就配置完成了 在启动es-head之前需要修改es的配置文件，允许远程访问es，在${ES_HOME}\config\elasticsearch.yml中添加如下配置： 1234567891011121314cluster.name: elk6 #集群名字node.name: &quot;elk-a1&quot; #节点名字node.master: true #主节点node.data: truediscovery.zen.ping.unicast.hosts: [&quot;192.168.x.x&quot;]discovery.zen.fd.ping_timeout: 60sdiscovery.zen.fd.ping_retries: 5indices.fielddata.cache.size: 40%bootstrap.system_call_filter: falsepath.data: /xx/elasticsearch #数据目录path.logs: /var/log/elasticsearch #日志目录network.host: 0.0.0.0http.cors.enabled: true #允许插件http.cors.allow-origin: &quot;*&quot; 最主要的是最后两条配置，这是允许es被跨域访问的配置安装完需要的依赖包之后就可以直接运行了可以直接使用浏览器运行es-head下index.html文件也可以使用npm run start运行，然后访问 http://localhost:9100即可：这就是es-head连接es的页面：点击indices可以查看当前es中包含的index（相当于mysql中的表）可以看到es中又8个index，但是以”.“开头的index是系统自带的，剩下的三个才是我们自己创建的index，这里的job就是我们在jdbc.conf中配置的 output { elasticsearch { index =&gt; &quot;job&quot; document_type =&gt; &quot;%{type}&quot; hosts =&gt; &quot;localhost:9200&quot; document_id =&gt; &quot;%{id}&quot; } stdout { codec =&gt; json_lines } } 中的index节点对应的命名空间好了，到这里mysql同步到es就可以说是完成了下一步我要实现springboot+ELK实现日志管理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot+elasticsearch+mybatis+mysql（一：简单整合）]]></title>
    <url>%2F2019%2F07%2F09%2Fspringboot-elasticsearch-mybatis-mysql%EF%BC%88%E4%B8%80%EF%BC%9A%E7%AE%80%E5%8D%95%E6%95%B4%E5%90%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[@TOC 参考文章：spring boot2 + mybatis + elasticsearch + mysql 整合（1）——项目搭建与测试springboot+es的四种方式1：通过intellij搭建springboot的项目：不多说（需要注意的是要在项目中选中web模块、sql中的jdbc、mysql、mybatis以及nosql中的elasticsearch模块）创建完成的项目结构如下：2：application.yml配置文件： 1234567891011121314151617181920212223server: port: 8080 tomcat: uri-encoding: UTF-8spring: data: elasticsearch: repositories: enabled: true cluster-name: elasticsearch cluster-nodes: localhost:9300# 日志配置logging: config: classpath:logback.xml # 日志输出根路径 exportPath: d://springboot-es/logs level: com.johndoeo.demo: debug org.springframework: WARN org.spring.springboot.dao: debug TestController.java 123456789101112131415161718package com.johndoeo.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** *@ClassName:TestController *@Descreption: TODO *@Author: JohnDoeo *@Date: 2019/7/3 10:26 */@Controllerpublic class TestController &#123; @RequestMapping(&quot;/hello&quot;) public String test()&#123; return &quot;hello es&quot;; &#125;&#125; 接下来启动项目，会报错，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374Logging system failed to initialize using configuration from &apos;classpath:logback.xml&apos;java.lang.IllegalStateException: Logback configuration error detected: ERROR in ch.qos.logback.core.joran.spi.Interpreter@3:82 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]] at org.springframework.boot.logging.logback.LogbackLoggingSystem.loadConfiguration(LogbackLoggingSystem.java:166) at org.springframework.boot.logging.AbstractLoggingSystem.initializeWithSpecificConfig(AbstractLoggingSystem.java:65) at org.springframework.boot.logging.AbstractLoggingSystem.initialize(AbstractLoggingSystem.java:56) at org.springframework.boot.logging.logback.LogbackLoggingSystem.initialize(LogbackLoggingSystem.java:117) at org.springframework.boot.context.logging.LoggingApplicationListener.initializeSystem(LoggingApplicationListener.java:284) at org.springframework.boot.context.logging.LoggingApplicationListener.initialize(LoggingApplicationListener.java:254) at org.springframework.boot.context.logging.LoggingApplicationListener.onApplicationEnvironmentPreparedEvent(LoggingApplicationListener.java:219) at org.springframework.boot.context.logging.LoggingApplicationListener.onApplicationEvent(LoggingApplicationListener.java:196) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127) at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:75) at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:53) at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:340) at org.springframework.boot.SpringApplication.run(SpringApplication.java:304) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1213) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1202) at com.johndoeo.demo.SpringbootEsDemoApplication.main(SpringbootEsDemoApplication.java:11)Disconnected from the target VM, address: &apos;127.0.0.1:56695&apos;, transport: &apos;socket&apos;11:04:00.462 [main] ERROR o.s.b.SpringApplication - [reportFailure,821] - Application run failedjava.lang.IllegalStateException: java.lang.IllegalStateException: Logback configuration error detected: ERROR in ch.qos.logback.core.joran.spi.Interpreter@3:82 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]] at org.springframework.boot.context.logging.LoggingApplicationListener.initializeSystem(LoggingApplicationListener.java:291) at org.springframework.boot.context.logging.LoggingApplicationListener.initialize(LoggingApplicationListener.java:254) at org.springframework.boot.context.logging.LoggingApplicationListener.onApplicationEnvironmentPreparedEvent(LoggingApplicationListener.java:219) at org.springframework.boot.context.logging.LoggingApplicationListener.onApplicationEvent(LoggingApplicationListener.java:196) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127) at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:75) at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:53) at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:340) at org.springframework.boot.SpringApplication.run(SpringApplication.java:304) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1213) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1202) at com.johndoeo.demo.SpringbootEsDemoApplication.main(SpringbootEsDemoApplication.java:11)Caused by: java.lang.IllegalStateException: Logback configuration error detected: ERROR in ch.qos.logback.core.joran.spi.Interpreter@3:82 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]] at org.springframework.boot.logging.logback.LogbackLoggingSystem.loadConfiguration(LogbackLoggingSystem.java:166) at org.springframework.boot.logging.AbstractLoggingSystem.initializeWithSpecificConfig(AbstractLoggingSystem.java:65) at org.springframework.boot.logging.AbstractLoggingSystem.initialize(AbstractLoggingSystem.java:56) at org.springframework.boot.logging.logback.LogbackLoggingSystem.initialize(LogbackLoggingSystem.java:117) at org.springframework.boot.context.logging.LoggingApplicationListener.initializeSystem(LoggingApplicationListener.java:284) ... 14 common frames omittedException in thread &quot;main&quot; java.lang.IllegalStateException: java.lang.IllegalStateException: Logback configuration error detected: ERROR in ch.qos.logback.core.joran.spi.Interpreter@3:82 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]] at org.springframework.boot.context.logging.LoggingApplicationListener.initializeSystem(LoggingApplicationListener.java:291) at org.springframework.boot.context.logging.LoggingApplicationListener.initialize(LoggingApplicationListener.java:254) at org.springframework.boot.context.logging.LoggingApplicationListener.onApplicationEnvironmentPreparedEvent(LoggingApplicationListener.java:219) at org.springframework.boot.context.logging.LoggingApplicationListener.onApplicationEvent(LoggingApplicationListener.java:196) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:127) at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:75) at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:53) at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:340) at org.springframework.boot.SpringApplication.run(SpringApplication.java:304) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1213) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1202) at com.johndoeo.demo.SpringbootEsDemoApplication.main(SpringbootEsDemoApplication.java:11)Caused by: java.lang.IllegalStateException: Logback configuration error detected: ERROR in ch.qos.logback.core.joran.spi.Interpreter@3:82 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]] at org.springframework.boot.logging.logback.LogbackLoggingSystem.loadConfiguration(LogbackLoggingSystem.java:166) at org.springframework.boot.logging.AbstractLoggingSystem.initializeWithSpecificConfig(AbstractLoggingSystem.java:65) at org.springframework.boot.logging.AbstractLoggingSystem.initialize(AbstractLoggingSystem.java:56) at org.springframework.boot.logging.logback.LogbackLoggingSystem.initialize(LogbackLoggingSystem.java:117) at org.springframework.boot.context.logging.LoggingApplicationListener.initializeSystem(LoggingApplicationListener.java:284) ... 14 more 可以看到这里是logback.xml文件的问题，我的logback.xml内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;log.path&quot; source=&quot;logging.exportPath&quot;/&gt; &lt;property name=&quot;log.pattern&quot; value=&quot;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;20&#125; - [%method,%line] - %msg%n&quot; /&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 系统日志输出 --&gt; &lt;appender name=&quot;file_info&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;log.path&#125;/sys-info.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 按天回滚 daily --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/sys-info.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 日志最大的历史 60天 --&gt; &lt;maxHistory&gt;60&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;appender name=&quot;file_error&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;log.path&#125;/sys-error.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/sys-error.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 日志最大的历史 60天 --&gt; &lt;maxHistory&gt;60&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 用户访问日志输出 --&gt; &lt;appender name=&quot;sys-user&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;log.path&#125;/sys-user.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 按天回滚 daily --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/sys-user.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 日志最大的历史 60天 --&gt; &lt;maxHistory&gt;60&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 显示形成的sql、使用的参数、结果集 --&gt; &lt;!-- &lt;logger name=&quot;java.sql&quot; level=&quot;debug&quot; /&gt; &lt;logger name=&quot;org.springframework.jdbc&quot; level=&quot;debug&quot; /&gt; --&gt; &lt;logger name=&quot;com.paamp&quot; level=&quot;info&quot; /&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;console&quot; /&gt; &lt;/root&gt; &lt;!--系统操作日志--&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;file_info&quot; /&gt; &lt;appender-ref ref=&quot;file_error&quot; /&gt; &lt;/root&gt; &lt;!--系统用户操作日志--&gt; &lt;logger name=&quot;sys-user&quot; level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;sys-user&quot;/&gt; &lt;/logger&gt;&lt;/configuration&gt; 可以看到我的这个配置文件中使用了springProperty 标签动态加载了application.yml中的配置项，而在官网上发现如果logback的配置文件名为logback.xml时会先加载logback的配置文件，而改成logback-spring.xml就会先加载application.yml，所以这里把logback.xml文件名改为logback-spring.xml ok，重新启动项目 然后又报了以下的错误： 1234567891011121314151617181920212211:09:46.681 [main] ERROR o.s.b.d.LoggingFailureAnalysisReporter - [report,40] - ***************************APPLICATION FAILED TO START***************************Description:Failed to configure a DataSource: &apos;url&apos; attribute is not specified and no embedded datasource could be configured.Reason: Failed to determine a suitable driver classAction:Consider the following:Disconnected from the target VM, address: &apos;127.0.0.1:56796&apos;, transport: &apos;socket&apos; If you want an embedded database (H2, HSQL or Derby), please put it on the classpath. If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).Process finished with exit code 1 从错误提示信息中可以看出来，这里的错误是springboot的自动配置找不到配置文件中的database.url的配置项，知道了报错的原因就好解决了，这里可以直接在启动类注解中添加一个属性exclude = {DataSourceAutoConfiguration.class}，最后的启动类SpringbootEsDemoApplication.java如下： 1234567891011121314package com.johndoeo.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;) public class SpringbootEsDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootEsDemoApplication.class, args); &#125;&#125; 这里是为了排除数据源的自动化配置，然后再次启动项目这次终于启动成功了，可是当我通过浏览器访问 http://localhost:8080/hello的时候页面无法访问到，页面出错：Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback. Wed Jul 03 11:15:02 CST 2019There was an unexpected error (type=Not Found, status=404).No message available 这个问题的出现可能是以下三种可能：（1）springboot启动类和controller类位置关系问题导致项目无法扫描到controller（但是我的项目中启动类和controller包同级）（2）可能是哪个controller文件没有注入或注入错误（但是我的项目中应该是没有问题的）（3）请求路径错误（这个更不可能了，我检查了好几次） 另外，浏览器访问这个路径的时候debug可以进入到controller中，但是返回后页面就是无法接收到返回的字符串（不知道是不是因为服务器自动把字符串当成一个页面进行加载了） 终于解决这个问题了：在controller的要返回字符串的方法上添加注解@ResponseBody就可以了 项目源码：https://github.com/JohnDoeo/springboot-learn/tree/master/springboot-es-demo]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法]]></title>
    <url>%2F2019%2F07%2F08%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[转载：原文链接：https://www.zybuluo.com/mdeditor# markdown语法欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。]]></content>
  </entry>
  <entry>
    <title><![CDATA[sql运行抛异常：ParseException.md]]></title>
    <url>%2F2019%2F06%2F21%2Fsql%E8%BF%90%E8%A1%8C%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%9AParseException%2F</url>
    <content type="text"><![CDATA[今天在项目运行过程中项目报错如下：（项目环境：springboot2.1.1+jdk8+springmvc+mybatis3.4.6+mybatisplus）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384net.sf.jsqlparser.JSQLParserException at net.sf.jsqlparser.parser.CCJSqlParserUtil.parse(CCJSqlParserUtil.java:56) at com.github.pagehelper.parser.OrderByParser.converToOrderBySql(OrderByParser.java:51) at com.github.pagehelper.dialect.AbstractHelperDialect.getPageSql(AbstractHelperDialect.java:176) at com.github.pagehelper.PageHelper.getPageSql(PageHelper.java:97) at com.github.pagehelper.PageInterceptor.intercept(PageInterceptor.java:129) at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:61) at com.sun.proxy.$Proxy185.query(Unknown Source) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433) at com.sun.proxy.$Proxy96.selectList(Unknown Source) at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:230) at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:139) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:76) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:59) at com.sun.proxy.$Proxy131.selectGwProjectList(Unknown Source) at com.paamp.gateway.service.impl.GwProjectServiceImpl.selectGwProjectList(GwProjectServiceImpl.java:47) at com.paamp.web.controller.gateway.GwProjectController.list(GwProjectController.java:56) at com.paamp.web.controller.gateway.GwProjectController$$FastClassBySpringCGLIB$$21de45ab.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor$1.proceed(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:82) at org.apache.shiro.authz.aop.AuthorizingMethodInterceptor.invoke(AuthorizingMethodInterceptor.java:39) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor.invoke(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:115) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:93) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) at com.paamp.web.controller.gateway.GwProjectController$$EnhancerBySpringCGLIB$$d65b9b63.list(&lt;generated&gt;) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:189) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:800) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1038) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:908) at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108) at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:112) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:112) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:61) at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108) at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66) at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108) at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66) at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108) at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66) at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449) at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365) at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90) at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83) at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:387) at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:791) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1417) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745)Caused by: net.sf.jsqlparser.parser.ParseException: Encountered " "(" "( "" at line 4, column 12.Was expecting one of: &lt;EOF&gt; "AS" ... "DO" ... "ANY" ... "KEY" ... "PERCENT" ... "END" ... "INTO" ... "FROM" ... "OPEN" ... "TABLE" ... "WHERE" ... "FOR" ... "XML" ... "UNION" ... "GROUP" ... "ORDER" ... "VALUE" ... "HAVING" ... "INSERT" ... "VALUES" ... "REPLACE" ... "TRUNCATE" ... "INTERSECT" ... "CAST" ... "EXCEPT" ... "MINUS" ... "OVER" ... "PARTITION" ... "EXTRACT" ... "MATERIALIZED" ... "START" ... "CONNECT" ... "PRIOR" ... "SIBLINGS" ... "COLUMN" ... "NULLS" ... "FIRST" ... "LAST" ... "ROWS" ... "RANGE" ... "FOLLOWING" ... "ROW" ... "COMMIT" ... "SEPARATOR" ... "CASCADE" ... "NO" ... "ACTION" ... &lt;K_DATETIMELITERAL&gt; ... "PRECISION" ... ";" ... &lt;S_IDENTIFIER&gt; ... &lt;S_QUOTED_IDENTIFIER&gt; ... "," ... "|" ... "&amp;" ... "^" ... "::" ... "ORDER" ... "ORDER" ... at net.sf.jsqlparser.parser.CCJSqlParser.generateParseException(CCJSqlParser.java:16395) at net.sf.jsqlparser.parser.CCJSqlParser.jj_consume_token(CCJSqlParser.java:16248) at net.sf.jsqlparser.parser.CCJSqlParser.Statement(CCJSqlParser.java:90) at net.sf.jsqlparser.parser.CCJSqlParserUtil.parse(CCJSqlParserUtil.java:54) ... 123 moreCaused by:net.sf.jsqlparser.parser.ParseException: Encountered " "(" "( "" at line 4, column 12.Was expecting one of: &lt;EOF&gt; "AS" ... "DO" ... "ANY" ... "KEY" ... "PERCENT" ... "END" ... "INTO" ... "FROM" ... "OPEN" ... "TABLE" ... "WHERE" ... "FOR" ... "XML" ... "UNION" ... "GROUP" ... "ORDER" ... "VALUE" ... "HAVING" ... "INSERT" ... "VALUES" ... "REPLACE" ... "TRUNCATE" ... "INTERSECT" ... "CAST" ... "EXCEPT" ... "MINUS" ... "OVER" ... "PARTITION" ... "EXTRACT" ... "MATERIALIZED" ... "START" ... "CONNECT" ... "PRIOR" ... "SIBLINGS" ... "COLUMN" ... "NULLS" ... "FIRST" ... "LAST" ... "ROWS" ... "RANGE" ... "FOLLOWING" ... "ROW" ... "COMMIT" ... "SEPARATOR" ... "CASCADE" ... "NO" ... "ACTION" ... &lt;K_DATETIMELITERAL&gt; ... "PRECISION" ... ";" ... &lt;S_IDENTIFIER&gt; ... &lt;S_QUOTED_IDENTIFIER&gt; ... "," ... "|" ... "&amp;" ... "^" ... "::" ... "ORDER" ... "ORDER" ... at net.sf.jsqlparser.parser.CCJSqlParser.generateParseException(CCJSqlParser.java:16395) at net.sf.jsqlparser.parser.CCJSqlParser.jj_consume_token(CCJSqlParser.java:16248) at net.sf.jsqlparser.parser.CCJSqlParser.Statement(CCJSqlParser.java:90) at net.sf.jsqlparser.parser.CCJSqlParserUtil.parse(CCJSqlParserUtil.java:54) at com.github.pagehelper.parser.OrderByParser.converToOrderBySql(OrderByParser.java:51) at com.github.pagehelper.dialect.AbstractHelperDialect.getPageSql(AbstractHelperDialect.java:176) at com.github.pagehelper.PageHelper.getPageSql(PageHelper.java:97) at com.github.pagehelper.PageInterceptor.intercept(PageInterceptor.java:129) at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:61) at com.sun.proxy.$Proxy185.query(Unknown Source) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433) at com.sun.proxy.$Proxy96.selectList(Unknown Source) at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:230) at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:139) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:76) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:59) at com.sun.proxy.$Proxy131.selectGwProjectList(Unknown Source) at com.paamp.gateway.service.impl.GwProjectServiceImpl.selectGwProjectList(GwProjectServiceImpl.java:47) at com.paamp.web.controller.gateway.GwProjectController.list(GwProjectController.java:56) at com.paamp.web.controller.gateway.GwProjectController$$FastClassBySpringCGLIB$$21de45ab.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor$1.proceed(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:82) at org.apache.shiro.authz.aop.AuthorizingMethodInterceptor.invoke(AuthorizingMethodInterceptor.java:39) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor.invoke(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:115) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:93) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) at com.paamp.web.controller.gateway.GwProjectController$$EnhancerBySpringCGLIB$$d65b9b63.list(&lt;generated&gt;) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:189) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:800) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1038) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:908) at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108) at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:112) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:112) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:61) at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108) at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66) at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108) at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66) at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108) at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66) at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449) at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365) at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90) at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83) at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:387) at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:791) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1417) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) 我的分页代码如下：1234567891011121314/** * 设置请求分页数据 */protected void startPage()&#123; PageDomain pageDomain = TableSupport.buildPageRequest(); Integer pageNum = pageDomain.getPageNum(); Integer pageSize = pageDomain.getPageSize(); if (StringUtils.isNotNull(pageNum) &amp;&amp; StringUtils.isNotNull(pageSize)) &#123; String orderBy = pageDomain.getOrderBy(); PageHelper.startPage(pageNum, pageSize, orderBy); &#125;&#125; 完全是常规操作，但是为什么会报这个错呢？找到了一片博客sql运行抛异常：Caused by: net.sf.jsqlparser.parser.ParseException 原因是count函数中嵌套了if函数导致抛异常，不使用“count(if(exprt))”嵌套函数就不会出现异常； 使用pageHelper5.1.4任然会报错]]></content>
      <tags>
        <tag>mybatis</tag>
        <tag>pagehelper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题总结.md]]></title>
    <url>%2F2019%2F02%2F27%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[参考链接① 参考链接②java基础部分：一、数据类型：1、String 是最基本的数据类型吗？不是。Java中的基本数据类型只有8个： byte、short、int、long、float、double、char、boolean； 除了基本类型（primitive type），剩下的都是引用类型（reference type）， Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。 2、float f=3.4;是否正确？不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float） 属于下转型（down-casting，也称为窄化）会造成精度损失， 因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F; 3、short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型， 所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。 对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符， java编译器会对它进行特殊处理，因此可以正确编译。 4、char型变量中能不能存贮一个中文汉字?为什么?在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量， 整数表达式可以是int基本类型或Integer包装类型， 由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。 显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型， 所以，它们不能作用于swtich语句中。 5、Integer与int的区别int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类， Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null， 即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况， 例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。 在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时， 值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0， 所以，int不适合作为web层的表单数据的类型。 6、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。 从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始， expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 7、数组有没有length()方法？String有没有length()方法？数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中， 获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。 8、String和StringBuilder、StringBuffer的区别？Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder， 它们可以储存和操作字符串。其中String是只读字符串， 也就意味着String引用的字符串内容是不能被改变的。 而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。 StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同， 区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰， 因此它的效率也比StringBuffer要高。 9、二、关键字：1、访问修饰符public,private,protected,以及不写（默认）时的区别？!(kk)[访问修饰符.jpg] 2、Java 中的final关键字有哪些用法？(1)修饰类：表示该类不能被继承； (2)修饰方法：表示方法不能被重写； (3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。 3、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。 在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。 当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息， 调用这个对象的方法可以捕获到这个异常并可以对其进行处理。 Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。 一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象， 可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理； try用来指定一块预防所有异常的程序； catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型； throw语句用来明确地抛出一个异常； throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）； finally为确保一段代码不管发生什么异常状况都要被执行； try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中， 直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理， 异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。 4、阐述final、finally、finalize的区别。final：修饰符（关键字）有三种用法：12345678910111213(1)如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。(2)将变量声明为final，可以保证它们在使用中不被改变， 被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改 （如果修饰引用，那么表示引用不可变，引用指向的内容可变）。(3)被声明为final的方法也同样只能使用，不能在子类中被重写。(4)被final修饰的方法，JVM会尝试将其内联，以提高运行效率 (5)被final修饰的常量，在编译阶段会存入常量池中。回答出编译器对final域要遵守的两个重排序规则更好：1.在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量, 这两个操作之间不能重排序。2.初次读一个包含final域的对象的引用，与随后初次读这个final域, 这两个操作之间不能重排序。 finally： 通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常， 这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。 finalize： Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象 从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的， 通过重写finalize()方法可以整理系统资源或者执行其他清理工作。 5、三、集合（java容器）数据结构和运算：1、用最有效率的方法计算2乘以8？2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。 2、计算一个数的质因数，例如：输入10，输出 10=12512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 System.out.println(&quot;请输入一个数!&quot;); Scanner sc = new Scanner(System.in); int num = Integer.parseInt(sc.next()); String str = num+&quot;=1&quot;; while(num != 1)&#123; for(int i = 2;i&lt;=num;i++)&#123; if(num%i==0)&#123; str = str +&quot;*&quot;+i; System.out.println(i); num = num/i; break; &#125; &#125; &#125; System.out.println(str);``` ### 3、&amp;和&amp;&amp;的区别？ &amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。 逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false， 右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;， 例如在验证用户登录时判定用户名不是null而且不是空字符串， 应当写为：username != null &amp;&amp;!username.equals(&quot;&quot;)，二者的顺序不能交换， 更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较， 否则会产生NullPointerException异常。 注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 ### 4、在Java中，如何跳出当前的多重嵌套循环？ 在最外层循环前加一个标记如A，然后用break A; 可以跳出多重循环。（Java中支持带标签的break和continue语句， 作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样， 应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅， 很多时候甚至有相反的作用，所以这种语法其实不知道更好） ### 5、List、Set、Map是否继承自Collection接口？ List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别， 而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此）， List是线性结构的容器，适用于按数值索引访问元素的情形。 ### 6、阐述ArrayList、Vector、LinkedList的存储性能和特性。 ArrayList 和Vector都是使用数组方式存储数据， 此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素， 但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢， Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器， 但性能上较ArrayList差，因此已经是Java中的遗留容器。 LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来， 形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比， 内存的利用率更高），按序号索引数据需要进行前向或后向遍历， 但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 Vector属于遗留容器（Java早期的版本中提供的容器，除此之外， Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器）， 已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的， 如果遇到多个线程操作同一个容器的场景， 则可以通过工具类Collections中的synchronizedList方法将其转换成 线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的 构造器中创建新的对象来增强实现）。 补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系（关联）或Use-A关系（依赖）。同理，Stack类继承Vector也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。 1234567891011121314151617181920212223242526272829303132### 7、Collection和Collections的区别？ Collection是一个接口，它是Set、List等容器的父接口； Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作， 这些方法包括对容器的搜索、排序、线程安全化等等。 ### 8、List、Map、Set三个接口存取元素时，各有什么特点？ List以特定索引来存取元素，可以有重复元素。 Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。 Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。 Set和Map容器都有基于哈希存储和排序树的两种实现版本， 基于哈希存储的版本理论存取时间复杂度为O(1)， 而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key） 构成排序树从而达到排序和去重的效果。 ### 9、 &quot;==&quot;和equals方法究竟有什么区别？ “==”操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同， 要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。 如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存， 对象本身占用一块内存（堆内存），变量也占用一块内存(栈内存)， 例如Objet obj = new Object();变量obj是一个内存，new Object()是另一个内存， 此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。 对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象， 即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。 equals方法是用于比较两个独立对象的内容是否相同， 就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。 例如，对于下面的代码： String a=new String(&quot;foo&quot;); String b=new String(&quot;foo&quot;); 123456789101112 两条new语句创建了两个对象，然后用a,b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。 在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input = …;input.equals(“quit”)，许多人稍不注意就使用==进行比较了，这是错误的，记住，字符串的比较基本上都是使用equals方法。 如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object类的equals方法的实现代码如下： boolean equals(Object o){ return this==o;}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 这说明，如果一个类没有自己定义equals方法，它默认的equals方法（从Object 类继承的） 就是使用==操作符，也是在比较两个变量指向的对象是否是同一对象， 这时候使用equals和使用==会得到同样的结果，如果比较的是两个独立的对象则总返回false。 如果你编写的类希望能够比较该类创建的两个实例对象的内容是否相同， 那么你必须覆盖equals方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。 ### 10、java 中的 Math常用方法？ 常用值与函数： Math.PI 记录的圆周率 Math.E 记录e的常量 Math中还有一些类似的常量，都是一些工程数学常用量。 Math.abs 求绝对值 Math.sin 正弦函数 Math.asin 反正弦函数 Math.cos 余弦函数 Math.acos 反余弦函数 Math.tan 正切函数 Math.atan 反正切函数 Math.atan2 商的反正切函数 Math.toDegrees 弧度转化为角度 Math.toRadians 角度转化为弧度 Math.ceil 得到不小于某数的最大整数 Math.floor 得到不大于某数的最大整数 Math.IEEEremainder 求余 Math.max 求两数中最大 Math.min 求两数中最小 Math.sqrt 求开方 Math.pow 求某数的任意次方, 抛出ArithmeticException处理溢出异常 Math.exp 求e的任意次方 Math.log10 以10为底的对数 Math.log 自然对数 Math.rint 求距离某数最近的整数（可能比某数大，也可能比它小） Math.round 同上，返回int型或者long型（上一个函数返回double型） Math.random 返回0，1之间的一个随机数 ### 11、位运算 &lt;&lt;:左移运算符 （左移位运算符（&lt;&lt;）能将运算符左边的运算对象向左移动运算符右侧指定的位数（在低位补0）） 例子：a&lt;&lt;b 相当于a乘以2的b次冥 &gt;&gt;:右移运算符 （“有符号”右移位运算符（&gt;&gt;）则将运算符左边的运算对象向右移动运算符右侧指定的位数。 “有符号”右移位运算符使用了“符号扩展”：若值为正，则在高位插入0；若值为负，则在高位插入1） 例子：a&gt;&gt;b 相当于a除以2的b次冥 &gt;&gt;&gt;：无符号右移，忽略符号位，空位都以0补齐 （“无符号”右移位运算符（&gt;&gt;&gt;），它使用了“零扩展”：无论正负，都在高位插入0） ^:按位异或可以用来使某些特定的位翻转， 如对数10100001的第2位和第3位翻转，可以将数与00000110进行按位异或运算。 10100001^00000110=10100111 //1010 0001 ^ 0x06 = 1010 0001 ^ 6 通过按位异或运算，可以实现两个值的交换，而不必使用临时变量。 例如交换两个整数a，b的值，可通过下列语句实现： a=10100001,b=00000110 a=a^b； //a=10100111 b=b^a； //b=10100001 a=a^b； //a=00000110 异或运算符的特点是：数a两次异或同一个数b（a=a^b^b）仍然为原值a. &amp;:与运算符用符号“&amp;”表示，其使用规律如下： 两个操作数中位都为1，结果才为1，否则结果为0。 |:或运算符用符号“|”表示，其运算规律如下： 两个位只要有一个为1，那么结果就是1，否则就为0。 ~:非运算符用符号“~”表示，其运算规律如下： 如果位为0，结果是1，如果位为1，结果是0。 ^:异或运算符是用符号“^”表示的，其运算规律是： 两个操作数的位中，相同则结果为0，不同则结果为1。 ### 12、 ## 四、多线程### 1、面向对象的特征有哪些方面？ 抽象：将同类对象的共同特征提取出来构造类。 继承：基于基类创建新类。 封装：将数据隐藏起来，对数据的访问只能通过特定接口。 多态性：不同子类型对象对相同消息作出不同响应。 ### 2、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别? sleep()方法（休眠）是线程类（Thread）的静态方法， 调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程， 但是对象的锁依然保持，因此休眠时间结束后会自动恢复 （线程回到就绪状态，请参考第66题中的线程状态转换图）。 wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行）， 进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法） 时才能唤醒等待池中的线程进入等锁池（lock pool）， 如果线程重新获得对象的锁就可以进入就绪状态。 补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的Node.js就采用了单线程异步I/O的工作模式。1234567891011121314151617181920212223242526### 3、线程的sleep()方法和yield()方法有什么区别？ ① sleep()方法给其他线程运行机会时不考虑线程的优先级， 因此会给低优先级的线程以运行的机会； yield()方法只会给相同优先级或更高优先级的线程以运行的机会； ② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态； ③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； ④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。 ### 4、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？ 不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。 因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁， 如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能 在等锁池（注意不是等待池哦）中等待对象的锁。 ### 5、请说出与线程同步以及线程调度相关的方法。 wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法， 调用此方法要处理InterruptedException异常； notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候， 并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程， 而是让它们竞争，只有获得锁的线程才能进入就绪状态； 补充：Java 5通过Lock接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。1234下面的例子演示了100个线程同时向一个银行账户中存入1元钱，在没有使用同步机制和使用同步机制情况下的执行情况。银行账户类： /** 银行账户 @author nnngu /public class Account { private double balance; // 账户余额 /** 存款 @param money 存入金额*/public void deposit(double money) { double newBalance = balance + money; try { Thread.sleep(10); // 模拟此业务需要一段处理时间 } catch(InterruptedException ex) { ex.printStackTrace(); } balance = newBalance;} /** 获得账户余额*/public double getBalance() { return balance;}}1存钱线程类： /** 存钱线程 @author nnngu /public class AddMoneyThread implements Runnable { private Account account; // 存入账户 private double money; // 存入金额 public AddMoneyThread(Account account, double money) { this.account = account; this.money = money; } @Override public void run() { account.deposit(money); } }1测试类： import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors; public class Test01 { public static void main(String[] args) { Account account = new Account(); ExecutorService service = Executors.newFixedThreadPool(100); for(int i = 1; i &lt;= 100; i++) { service.execute(new AddMoneyThread(account, 1)); } service.shutdown(); while(!service.isTerminated()) {} System.out.println(&quot;账户余额: &quot; + account.getBalance()); } }123456789在没有同步的情况下，执行结果通常是显示账户余额在10元以下，出现这种状况的原因是，当一个线程A试图存入1元的时候，另外一个线程B也能够进入存款的方法中，线程B读取到的账户余额仍然是线程A存入1元钱之前的账户余额，因此也是在原来的余额0上面做了加1元的操作，同理线程C也会做类似的事情，所以最后100个线程执行结束时，本来期望账户余额为100元，但实际得到的通常在10元以下（很可能是1元哦）。解决这个问题的办法就是同步，当一个线程对银行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行操作，代码有如下几种调整方案：在银行账户的存款（deposit）方法上加同步（synchronized）关键字 /** 银行账户 @author nnngu /public class Account { private double balance; // 账户余额 /** 存款 @param money 存入金额*/public synchronized void deposit(double money) { double newBalance = balance + money; try { Thread.sleep(10); // 模拟此业务需要一段处理时间 } catch(InterruptedException ex) { ex.printStackTrace(); } balance = newBalance;} /** 获得账户余额*/public double getBalance() { return balance;}}1在线程调用存款方法时对银行账户进行同步 /** 存钱线程 @author nnngu /public class AddMoneyThread implements Runnable { private Account account; // 存入账户 private double money; // 存入金额 public AddMoneyThread(Account account, double money) { this.account = account; this.money = money; } @Override public void run() { synchronized (account) { account.deposit(money); } } }1通过Java 5显示的锁机制，为每个银行账户创建一个锁对象，在存款操作进行加锁和解锁的操作 import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock; /** 银行账户 @author nnngu /public class Account { private Lock accountLock = new ReentrantLock(); private double balance; // 账户余额 /** 存款 @param money 存入金额*/public void deposit(double money) {accountLock.lock();try {double newBalance = balance + money;try {Thread.sleep(10); // 模拟此业务需要一段处理时间}catch (InterruptedException ex) {ex.printStackTrace();}balance = newBalance;}finally {accountLock.unlock();}} /** 获得账户余额*/public double getBalance() { return balance;}}12345678910111213按照上述三种方式对代码进行修改后，重写执行测试代码Test01，将看到最终的账户余额为100元。当然也可以使用Semaphore或CountdownLatch来实现同步。### 6、编写多线程程序有几种实现方式？ Java 5以前实现多线程有两种实现方法： 一种是继承Thread类； 另一种是实现Runnable接口。 两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者， 因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了， 显然使用Runnable接口更为灵活。补充：Java 5以后创建线程还有第三种方式：实现Callable接口， 该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示： import java.util.ArrayList;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future; class MyTask implements Callable { private int upperBounds; public MyTask(int upperBounds) { this.upperBounds = upperBounds; } @Override public Integer call() throws Exception { int sum = 0; for(int i = 1; i &lt;= upperBounds; i++) { sum += i; } return sum; } } class Test { public static void main(String[] args) throws Exception { List&lt;Future&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); ExecutorService service = Executors.newFixedThreadPool(10); for(int i = 0; i &lt; 10; i++) { list.add(service.submit(new MyTask((int) (Math.random() * 100)))); } int sum = 0; for(Future&lt;Integer&gt; future : list) { // while(!future.isDone()) ; sum += future.get(); } System.out.println(sum); } }1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 ### 7、synchronized关键字的用法？ synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问， 可以用synchronized(对象) &#123; … &#125;定义同步代码块， 或者在声明方法时将synchronized作为方法的修饰符。 ### 8、举例说明同步和异步。 如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源）， 例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了， 那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。 当应用程序在对象上调用了一个需要花费很长时间来执行的方法， 并且不希望让程序等待方法的返回时，就应该使用异步编程， 在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作， 而异步就是非阻塞式操作。 ### 9、什么是线程池（thread pool）？ 在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源 或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象， 以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能 减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁， 这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程 放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要 销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 Java 5+中的Executor接口定义一个执行线程的工具。 它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的， 尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors里面提供了一些 静态工厂方法，生成一些常用的线程池，如下所示： newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作， 也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束， 那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程， 直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变， 如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务 所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时， 此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制， 线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及 周期性执行任务的需求。 ### 10、简述synchronized 和java.util.concurrent.locks.Lock的异同？ Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点： Lock 能完成synchronized所实现的所有功能； 主要不同点：Lock有比synchronized更精确的线程语义和更好的性能， 而且不强制性的要求一定要获得锁。synchronized会自动释放锁， 而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外 部资源的最好的地方）。 ### 11、 Java中实现线程阻塞的方法?阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪） （1）线程睡眠：Thread.sleep (long millis)方法，使线程转到阻塞状态。 millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。 sleep()平台移植性好。 （2）线程等待：Object类中的wait()方法，导致当前的线程等待， 直到其他线程调用此对象的 notify() 唤醒方法。这个两个唤醒方法也是Object类中的方法， 行为等价于调用 wait() 一样。wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数， 另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态， 后者则必须对应的 notify() 被调用. （3）线程礼让，Thread.yield() 方法，暂停当前正在执行的线程对象， 把执行机会让给相同或者更高优先级的线程。yield() 使得线程放弃当前分得的 CPU 时间， 但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。 调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程. （4）线程自闭，join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法， 则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。 （5）suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态， 并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。 典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形： 测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。 因为有死锁倾向。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115### 12、Thread类常用方法： sleep(): 强迫一个线程睡眠Ｎ毫秒。 isAlive(): 判断一个线程是否存活。 join(): 等待线程终止。 activeCount(): 程序中活跃的线程数。 enumerate(): 枚举程序中的线程。 currentThread(): 得到当前线程。 isDaemon(): 一个线程是否为守护线程。 setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) setName(): 为线程设置一个名称。 wait(): 强迫一个线程等待。 notify(): 通知一个线程继续运行。 setPriority(): 设置一个线程的优先级。 可以参考下面这篇文章 [Java线程阻塞方法sleep()和wait()精炼详解](https://blog.csdn.net/weixin_41101173/article/details/79889464)wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁 ### 13、产生死锁的条件 1.互斥条件：一个资源每次只能被一个进程使用。 2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 ### 14、为什么wait, nofity和nofityAll这些方法不放在Thread类当中 一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。 如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。 如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。 简单的说，由于wait，notify和notifyAll都是锁级别的操作， 所以把他们定义在Object类中因为锁属于对象。### 15、什么是多线程的上下文切换 多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。### 16、synchronized和ReentrantLock的区别 synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。 既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性， 可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： （1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 （2）ReentrantLock可以获取各种锁的信息 （3）ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁， synchronized操作的应该是对象头中mark word。### 17、Java当中有哪几种锁 1、自旋锁: 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间， 为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会， 但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。 在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定。 2、偏向锁: 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取， 则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利， 如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。 3、轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态， 无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级， 意味着偏向锁升级成轻量级锁后不能降级成偏向锁。### 18、## 五、常用方法### 1、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？ 不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。 Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true）， 那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。 当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时， 相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统， 如果哈希码频繁的冲突将会造成存取性能急剧下降）。 补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已， 在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、 《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍，如果你还没看过， 那就赶紧去亚马逊买一本吧）中是这样介绍equals方法的： 首先equals方法必须满足自反性（x.equals(x)必须返回true）、 对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、 传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true） 和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值）， 而且对于任何非null值的引用x，x.equals(null)必须返回false。 实现高质量的equals方法的诀窍包括： 1. 使用==操作符检查&quot;参数是否为这个对象的引用&quot;； 2. 使用instanceof操作符检查&quot;参数是否为正确的类型&quot;； 3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配； 4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性； 5. 重写equals时总是要重写hashCode； 6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。### 2、如何实现对象克隆？ 有两种方式： 1). 实现Cloneable接口并重写Object类中的clone()方法； 2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆， 可以实现真正的深度克隆，代码如下： import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable; public class MyUtil { private MyUtil() { throw new AssertionError(); } @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T extends Serializable&gt; T clone(T obj) throws Exception { ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(obj); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); return (T) ois.readObject(); // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放 } } 下面是测试代码：import java.io.Serializable; /** 人类 @author nnngu /class Person implements Serializable { private static final long serialVersionUID = -9102017020286042305L; private String name; // 姓名 private int age; // 年龄 private Car car; // 座驾 public Person(String name, int age, Car car) { this.name = name; this.age = age; this.car = car; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Car getCar() { return car; } public void setCar(Car car) { this.car = car; } @Override public String toString() { return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, car=&quot; + car + &quot;]&quot;; } } /** 小汽车类 @author nnngu /class Car implements Serializable { private static final long serialVersionUID = -5713945027627603702L; private String brand; // 品牌 private int maxSpeed; // 最高时速 public Car(String brand, int maxSpeed) { this.brand = brand; this.maxSpeed = maxSpeed; } public String getBrand() { return brand; } public void setBrand(String brand) { this.brand = brand; } public int getMaxSpeed() { return maxSpeed; } public void setMaxSpeed(int maxSpeed) { this.maxSpeed = maxSpeed; } @Override public String toString() { return &quot;Car [brand=&quot; + brand + &quot;, maxSpeed=&quot; + maxSpeed + &quot;]&quot;; } } class CloneTest { public static void main(String[] args) { try { Person p1 = new Person(&quot;郭靖&quot;, 33, new Car(&quot;Benz&quot;, 300)); Person p2 = MyUtil.clone(p1); // 深度克隆 p2.getCar().setBrand(&quot;BYD&quot;); // 修改克隆的Person对象p2关联的汽车对象的品牌属性 // 原来的Person对象p1关联的汽车不会受到任何影响 // 因为在克隆Person对象时其关联的汽车对象也被克隆了 System.out.println(p1); } catch (Exception e) { e.printStackTrace(); } } }123456789101112131415161718192021222324252627282930313233343536373839404142434445注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。### 3、## 六、java面向对象### 1、构造器（constructor）是否可被重写（override）？ 构造器不能被继承，因此不能被重写，但可以被重载。 ### 2、是否可以继承String类？ String 类是final类，不可以被继承。 补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A） 和依赖关系（Use-A）而不是继承关系（Is-A）。 ### 3、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是按值传递还是按引用传递？ 是按值传递。Java语言的方法调用只支持参数的按值传递。 当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。 对象的属性可以在被调用过程中被改变，但在方法内部对对象引用的改变是不会影响到被调用者的。 C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。 在C#中可以编写如下所示的代码，但是在Java中却做不到。 ### 4、抽象类（abstract class）和接口（interface）有什么异同？ 抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现， 否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器， 可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。 抽象类中的成员可以是private、默认、protected、public的， 而接口中的成员全都是public的。抽象类中可以定义成员变量， 而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类， 而抽象类未必要有抽象方法。 ### 5、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？ Static Nested Class是被声明为静态（static）的内部类， 它可以不依赖于外部类实例被实例化。 而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。 /** 扑克类（一副扑克） /public class Poker { private static String[] suites = {“黑桃”, “红桃”, “草花”, “方块”}; private static int[] faces = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}; private Card[] cards; /** 构造器 */public Poker() { cards = new Card[52]; for(int i = 0; i &lt; suites.length; i++) { for(int j = 0; j &lt; faces.length; j++) { cards[i * 13 + j] = new Card(suites[i], faces[j]); } }} /** 洗牌 （随机乱序） */public void shuffle() { for(int i = 0, len = cards.length; i &lt; len; i++) { int index = (int) (Math.random() * len); Card temp = cards[index]; cards[index] = cards[i]; cards[i] = temp; }} /** 发牌 @param index 发牌的位置 */public Card deal(int index) { return cards[index];} /** 卡片类（一张扑克） [内部类] /public class Card { private String suite; // 花色 private int face; // 点数 public Card(String suite, int face) { this.suite = suite; this.face = face; } @Override public String toString() { String faceStr = &quot;&quot;; switch(face) { case 1: faceStr = &quot;A&quot;; break; case 11: faceStr = &quot;J&quot;; break; case 12: faceStr = &quot;Q&quot;; break; case 13: faceStr = &quot;K&quot;; break; default: faceStr = String.valueOf(face); } return suite + faceStr; }}} 1测试代码： class PokerTest { public static void main(String[] args) { Poker poker = new Poker(); poker.shuffle(); // 洗牌 Poker.Card c1 = poker.deal(0); // 发第一张牌 // 对于非静态内部类Card // 只有通过其外部类Poker对象才能创建Card对象 Poker.Card c2 = poker.new Card(&quot;红心&quot;, 1); // 自己创建一张牌 System.out.println(c1); // 洗牌后的第一张 System.out.println(c2); // 打印: 红心A } }1---面试题 - 下面的代码哪些地方会产生编译错误？ class Outer { class Inner {} public static void foo() { new Inner(); } public void bar() { new Inner(); } public static void main(String[] args) { new Inner(); } }1234注意：Java中非静态内部类对象的创建要依赖其外部类对象， 上面的面试题中foo和main方法都是静态方法，静态方法中没有this， 也就是说没有所谓的外部类对象，因此无法创建内部类对象， 如果要在静态方法中创建内部类对象，可以这样做： new Outer().new Inner(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344 ### 6、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？ 都不能。 抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。 本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。 synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。### 7、阐述静态变量和实例变量的区别。 静态变量是被static修饰符修饰的变量，也称为类变量，它属于类， 不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝； 实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。 静态变量可以实现让多个对象共享内存。 ### 8、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？ 不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象， 在调用静态方法时可能对象并没有被初始化。 ### 9、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？ 接口可以继承接口，而且支持多重继承。 抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。 ### 10、一个&quot;.java&quot;源文件中是否可以包含多个类（不是内部类）？有什么限制？ 可以，但一个源文件中最多只能有一个公开类（public class） 而且文件名必须和公开类的类名完全保持一致。 ### 11、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？ 可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。 ### 12、运行时异常与受检异常有何异同？ 异常表示程序运行过程中可能出现的非正常状态， 运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误， 只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关， 即使程序设计无误，仍然可能因使用的问题而引发。 Java编译器要求方法必须声明抛出可能发生的受检异常， 但是并不要求必须声明抛出未被捕获的运行时异常。 异常和继承一样，是面向对象程序设计中经常被滥用的东西， 在Effective Java中对异常的使用给出了以下指导原则： 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常） 对可以恢复的情况使用受检异常，对编程错误使用运行时异常 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生） 优先使用标准的异常 每个方法抛出的异常都要有文档 保持异常的原子性 不要在catch中忽略掉捕获到的异常 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657### 13、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性， 而后者实现的是运行时的多态性。重载发生在一个类中， 同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载； 重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型， 比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。 重载对返回类型没有特殊的要求。### 14、## 七、JVM### 1、描述一下JVM加载class文件的原理机制？ JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的， Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序， 而是一个或多个类文件。当Java程序需要使用某个类时， JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。 类的加载是指把类的.class文件中的数据读入到内存中， 通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。 加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段， 这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值） 和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化， 包括： 1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类； 2)如果类中存在初始化语句，就依次执行这些初始化语句。 类的加载是由类加载器完成的， 类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、 系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。 从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。 PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器， 其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载， 父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。 下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）； Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap； System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。 它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类， 是用户自定义加载器的默认父加载器。 ### 2、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。 通常我们定义一个基本数据类型的变量，一个对象的引用， 还有就是函数调用的现场保存都使用JVM中的栈空间； 而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域， 由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代， 再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured； 方法区和堆都是各个线程共享的内存区域， 用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据； 程序中的字面量（literal）如直接书写的100、&quot;hello&quot;和常量都是放在常量池中，常量池是方法区的一部分，。 栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间， 栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError， 而堆和常量池空间不足则会引发OutOfMemoryError。 补充1：较新版本的Java（从Java 6的某个更新开始）中， 由于JIT编译器的发展和&quot;逃逸分析&quot;技术的逐渐成熟， 栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。 补充2：运行时常量池相当于Class文件常量池具有动态性， Java语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中， String类的intern()方法就是这样的。 1234567891011121314 ### 3、解释jvm内存结构： ### 4、Java 中会存在内存泄漏吗，请简单描述。 理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题 （这也是Java被广泛使用于服务器端编程的一个重要原因）； 然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收， 因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态， 垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象， 如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。 下面例子中的代码也会导致内存泄露。 import java.util.Arrays;import java.util.EmptyStackException; public class MyStack { private T[] elements; private int size = 0; private static final int INIT_CAPACITY = 16; public MyStack() { elements = (T[]) new Object[INIT_CAPACITY]; } public void push(T elem) { ensureCapacity(); elements[size++] = elem; } public T pop() { if(size == 0) throw new EmptyStackException(); return elements[--size]; } private void ensureCapacity() { if(elements.length == size) { elements = Arrays.copyOf(elements, 2 * size + 1); } } }` 上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题， 它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题， 当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收， 即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用 （obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的， 这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了， 那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象， 即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外， 从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据）， 甚至造成OutOfMemoryError。 5、GC是什么？为什么要有GC？GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方， 忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃， Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的， Java语言没有提供释放已分配内存的显式操作方法。Java程序员不用担心内存管理， 因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一： System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显式的垃圾回收调用。 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。 垃圾回收器通常是作为一个单独的低优先级的线程运行， 不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收， 程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。 在Java诞生初期，垃圾回收是Java最大的亮点之一， 因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁， 如今Java的垃圾回收机制已经成为被诟病的东西。 移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验， 其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。 补充：垃圾回收机制有很多种， 包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。 标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。 Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进， 采用“分代式垃圾收集”。这种方法会根据Java对象的生命周期将堆内存划分为不同的区域， 在垃圾收集过程中，可能会将对象移动到不同区域： 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。 与垃圾回收相关的JVM参数： -Xms / -Xmx — 堆的初始大小 / 堆的最大大小 -Xmn — 堆中年轻代的大小 -XX:-DisableExplicitGC — 让System.gc()不产生任何作用 -XX:+PrintGCDetails — 打印GC的细节 -XX:+PrintGCDateStamps — 打印GC操作的时间戳 -XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小 -XX:NewRatio — 可以设置老生代和新生代的比例 -XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布 -XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold： 设置老年代阀值的初始值和最大值 -XX:TargetSurvivorRatio：设置幸存区的目标使用率 6、六、java I/O、NIO、1、Java中有几种类型的流？字节流和字符流。字节流继承于InputStream、OutputStream， 字符流继承于Reader、Writer。在 java.io 包中还有许多其他的流， 主要是为了提高性能和使用方便。 关于Java的I/O需要注意的有两点： 一是两种对称性（输入和输出的对称性，字节和字符的对称性）； 二是两种设计模式（适配器模式和装潢模式）。 另外Java中的流不同于C#的是它只有一个维度一个方向。]]></content>
      <categories>
        <category>java基础-面试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题添加相册功能]]></title>
    <url>%2F2019%2F02%2F26%2Fhexo%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[插入一个如片试试看 博客原链接：https://asdfv1929.github.io/2018/05/26/next-add-photos/]]></content>
      <tags>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo文章发布加密.md]]></title>
    <url>%2F2019%2F02%2F23%2Fhexo%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%8A%A0%E5%AF%86-md%2F</url>
    <content type="text"><![CDATA[最终效果图具体实现方法 打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码： 代码如下： &lt;script&gt; (function () { if (&apos;{{ page.password }}&apos;) { if (prompt(&apos;请输入文章密码&apos;) !== &apos;{{ page.password }}&apos;) { alert(&apos;密码错误！&apos;); if (history.length === 1) { location.replace(&quot;http://xxxxxxx.xxx&quot;); // 这里替换成你的首页 } else { history.back(); } } } })(); &lt;/script&gt; 然后在文章上写成类似这样：]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试显示版权信息.md]]></title>
    <url>%2F2019%2F02%2F23%2F%E6%B5%8B%E8%AF%95%E6%98%BE%E7%A4%BA%E7%89%88%E6%9D%83%E4%BF%A1%E6%81%AF-md%2F</url>
    <content type="text"><![CDATA[修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： @import “my-post-copyright”保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 小技巧：如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加： 这样每次hexo new “你的内容”之后，生成的md文件会自动把copyright:加到里面去(注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/前端小项目：使用canvas绘画哆啦A梦.html,那么在根目录下_config.yml中写成类似这样：）就行了。]]></content>
      <categories>
        <category>hexo博客搭建</category>
      </categories>
      <tags>
        <tag>copyright</tag>
      </tags>
  </entry>
</search>
